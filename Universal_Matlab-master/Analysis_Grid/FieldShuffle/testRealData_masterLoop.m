function [ allData, failTrl, failTet, failCell ] = testRealData_masterLoop(  )
%TESTREALDATA_MASTERLOOP Detect GC in rat data with various shuffles
% Master loop that controls the processing of a large population of cell in
% real recordings from the MEC. Aim is to detect grid cells based on
% different versions of gridness and different versions of shuffle.
%
% RETURNS
% allData       A single master cell array with a row per cell. The columns
%               are as follows.
%               i) filename
%               ii) tetrode
%               iii) cell number
%               iv) scale from sac in cm
%               v)

% ---
% HOUSE KEEPING
gcp             %Start pool if not started

% --- VARS ----------------------------------------------------------------
% Data and cuts are storred sepeartly - because Francesca made the cuts.
% Within each of these folder the data per rat follows my normal strucutre
% (e.g. ratNo/data/)
path2data       ='/Users/caswell/Documents/Data/';
path2cuts       ='/Users/caswell/Dropbox/Matlab/Data_Analysis/2015/FieldShuffle/RealData/FC_cuts/';

%Also need the path and file name of an xls doc that specifies which cells
%to load - details should be in sheet1
path2xls        ='/Users/caswell/Dropbox/Matlab/Data_Analysis/2015/FieldShuffle/RealData/';
flnm2xls        ='AllCutCells.xls'; %The FULL LIST
% flnm2xls        ='AllCutCellsSubTestSet.xls'; % The SHORT TEST LIST

%Define how many shuffles to do for each cell to get sig - note must match
%the number used for the synthetic data (typically 100)
nLpForShuf          =100; %For each rm how many shuffles to do get sig [100]


% --- LOAD AND PROCESS DATA -----------------------------------------------
[~,~,raw]        =...
    xlsread([path2xls, flnm2xls]);

%Remove header and unwanted columns - 1 row of header and we only need
%colsB,I,L,M,N,O (i.e. 2, 9, 12-15)
raw             =raw(2:end,[2,9,12:16]);


% --- START MAIN LOOP OVER EACH TRIAL THEN EACH CELL ----------------------
%Pretty straight forwards just loop over each trial (row in xls) then a
%second loop to try and load the spikes for each cell. Use try and catch as
%there are bound to be some dodgy ones. NB
%Will store data in a growing cell array - not ideal
[failTrl, failTet, failCell, allData] =deal(cell(0));

currRow         =1;
h               =waitbar(0, 'Looping over trials...');
for nn          =1:size(raw,1) %Start loop over trials
    
    %i) Recreate path to the data and get flname
    %Folder for each day is yy-mm-dd
    dayFln          =num2str(raw{nn,2});
    dayPth          =[raw{nn,7} '-' dayFln(4:5) '-' dayFln(6:7)];
    filePth         =[path2data, num2str(raw{nn,1}), filesep, dayPth, filesep];
    
    
    %ii) Read the DACQ files in - uses local file that is optimised for
    %speed. Note uses by default_vars folder to specify various values
    try
        data            =testRealData_readDACQ( [filePth, dayFln '.set'] );
    catch
        failTrl{end+1}  =[filePth, dayFln] ;
        continue
    end
    
    %iii) Determine a binSize in pix to get 2cm bins
    ppm             =str2num(data.pos.header{strcmp('pixels_per_metre', data.pos.header(:,1)),2});
    binSize         =(ppm/100)*2; %Pixels per 2cm
    
    
    %--- Now loop over tetrode ---
    %iv) determine which tetrodes actually had cells on them and hence
    %which we need to look at. Max of 4 tets.
    tet2ld        =zeros(1,4);
    tet2ld(1)     =~any(isnan(raw{nn,3}));
    tet2ld(2)     =~any(isnan(raw{nn,4}));
    tet2ld(3)     =~any(isnan(raw{nn,5}));
    tet2ld(4)     =~any(isnan(raw{nn,6}));
    tet2ld        =find(tet2ld);
    
    for tt        =1:length(tet2ld)
        %v) Determine which cells are present - numbers shoudld be
        %seperated by space and load appropriate cut file
        tetIds              =[data.tetrode.id];
        if ischar(raw{nn, tet2ld(tt)+2}) %Stored as string
            cells2use       =cell2mat(textscan(raw{nn,tet2ld(tt)+2}, '%u'));
        else
            cells2use       =raw{nn, tet2ld(tt)+2}; %Number
        end
        %Format of cut files generated by fc is flnm_tetfin.cut e.g.
        %21406171_3fin.cut
        cutFlnm       =[path2cuts, num2str(raw{nn,1}), filesep, dayPth, ...
            filesep, num2str(raw{nn,2}), '_', num2str(tet2ld(tt)), 'fin.cut'];
        
        try
            exactCut      =read_cut_file(cutFlnm);
        catch
            failTet{end+1}    =cutFlnm;
            continue
        end
        
        %Match to id
        tetInd              =find(tetIds==tet2ld(tt));
        
        %Check exactCut same length as pos - if longer truncate - this
        %happens sometimes. pos_sample is shorter than timestamp and
        %exactCut - should be safe to shorten them.
        if length(exactCut)>length(data.tetrode(tetInd).pos_sample)
            exactCut        =exactCut(1:length(data.tetrode(tetInd).pos_sample)); 
        end
        
        %Finally loop over each cell
        for cc       =1:length(cells2use)
            spkPos   =data.tetrode(tetInd).pos_sample(exactCut==cells2use(cc));
            
            if isempty(spkPos) %If not matches in cut record and cont
                failCell{end+1}     ={cutFlnm, cells2use(cc)};
                continue
            end
            
            %Finally do the analysis we came here for and save into
            %cell array
            [ grid, pVal, gridFrmShuff, gScl  ] ...
                =fs_masterAnalysis( data.pos, spkPos, binSize, nLpForShuf);
            allData{currRow,1}    =[filePth, dayFln]; %Filename and path
            allData{currRow,2}    =tet2ld(tt); %Tetrode
            allData{currRow,3}    =cells2use(cc); %Cell number
            allData{currRow,4}    =gScl * 2; %Grid scale in cm - 2cm bins
            allData{currRow,5}    =grid; %Gridness all four
            allData{currRow,6}    =pVal; %Gridness 95% for bth shuffle and all four g
            allData{currRow,7}    =gridFrmShuff; %Shuffled g
            
            currRow         =currRow+1;
        end
        
        
    end
    waitbar(nn/size(raw,1));
end
close(h);

end

