function [DATA]=circ_regress_cb(x,t,k,ppdir)
% Function to find approximation to circular-linear regression for phase
% precession.
% NB. Two methods for calculating circ_circ corr - Kempter method and
% method described in Fischer. Change code on or close to line 188 to
% switch between these. Kempter is preferred though.
%
% ARGS
% x - n-by-1 list of in-field positions (linear variable)
% t - n-by-1 list of phases in rads taken mod(2pi) i.e. between 0 and 2pi
% k - number of random permutations to perform, to calculate p-value of fit
%     usually set to 1000 but recommend 10k for stable p value estimate
%     1000> will take time 10k~20s
% ppdir - [scalar] to constrain slope, to avoid spurious
% values. Set to  0, to perform unconstrained optimisation.
% Otherwise specify -1 or 1 to require gradient to be -ve or +ve 
% respectivly. Range of gradients is hard coded to 4pi.
%
% RETURNS
% DATA - a structure with following elements
% *.slope_opt - slope of best fit (in rad/pos)
% *.fval_opt - value of cost function returned by fminbnd
% *phase_opt - phase offset in rads (i.e. value at pos=0
% *.cor - Kempter R from Fisher (see notes below)
% *.psim - a P value calculated by doing k permutation of the data and
%       getting a correlation for each then comparing with real p value
%
% So to plot best fit line on the graph above
% x=[0,1]
% y=rad2deg(x.*DATA.slope_opt + DATA.phase_opt)
% plot(x,y+360)
%
%
% Acknowledgments:
% Function writen by AJ adapted from Raluca code and updated further by CB
% Fisher, N. I. 1996
% Schmidt, Diba, Leibold, Schmitz, Buzsáki & Kempter 2009
% Kepmter et al (2012)
%
% CB see notes made in onenote under circular-linear regression
% NB requires circ_stat tool box for calc of residual vector
%
% CB ammended this code from circ_regeress_b to replace lines that did a
% Pearson corr (the value of which depended on the phase offset of values -
% see onenote for details) with lines suggested by Kempter (2012) to
% transfrom the linear variable to circular and then the circ_circ
% correlation from Fisher (eq6.36) which is basically what Kempter use as
% well.


%% Example: Data set B.20 on page 252 of Fisher used in example $6.9 on 
% page 160. x is distance and t is direction. 
% In example a circ-circ correlation after taking 2.*atan(t)  - circ-circ
% correlation is as described in section 6.3.3 on page 151 should give an R
% value of R=-0.316 and p (generated by perumtation) of p=0.057
% x = [107 46 33 67 122 69 43 30 12 25 37 69 5 83 68 38 21 1 71 60 71 71 57 53 38 70 7 48 7 21 27];
% t = [67 66 74 61 58 60 100 89 171 166 98 60 197 98 86 123 165 133 101 105 71 84 75 98 83 71 74 91 38 200 56]*(pi/180);
% [DATA]=circ_regress_b(x,t,10000,0)

%% Housekeeping
% goPar; %Start parallel workers if available - for loop over p value shuffle

% Check dimensional consistency of inputs - want two col vectors of same
% length
x           =x(:);
t           =t(:);
if any(size(x)~=size(t))
    error('x and t must be of the same size/dimensionality');
end


% Remove nans in either vector from both
valid       =~(isnan(x) | isnan(t)); %Non nans
x           =x(valid);
t           =t(valid);


% Check if valus are in radians - all values should be between 0 and 2pi,
% so should have been taken mod(2pi)
if any(t>(2*pi)) || any(t<0)
    error('Angular values outside the allowed range [0 to 2pi].');
end


%Check if there are enough values to get a valid line - n>=3
if length(x)<3
    DATA.slope_opt=nan;
    DATA.phase_opt=nan;
    DATA.fval_opt=nan;
    DATA.corr=nan;
    DATA.psim=nan;
    return
end

% Set constraints on slope min/max given the data - this for phase
% precession: if we can be sure that phase precession must be in a certain
% direction, say because we know that intrinsic frequencuy is mostly above
% theta frequency or vice versa, we can setup the constraints on the slope
% to exclude spuriously high or low gradients. If ie = +1, the slope is
% constrained to be NEGATIVE, if ie = -1 slope is constrained to be
% POSITIVE. If ppdir = [], then this code produces unconstrained
% optimisation.
h = ppdir(1);% ie = ppdir(2);
if h==-1 %&& ie==1
    con = [-1 eps];
elseif h==1 %&& ie==-1
    con = [eps 1];
else
    con = [-1 1-eps];
end

% Constrain maximum slope to give at most 360 deg phase precession over the
% field.
max_slope = (4*pi)/(max(x)-min(x));

%Then do linear circular correlation on the data
DATA   = lcc(x,t,max_slope,con);



%Now get a p value - note is possible to calcuate this numericallly see
%p122 of Kempter but I'm going to do a shuffle. So random permute of phases
%relative to the positions and check if correlation is more significant.
%Previously did this without recalcualating the slop that gives most phase
%precession - but having done some checking it appears it's more
%conservative (though slower) to shuffle, recalc gradient, then get
%correlation
n=length(t);
corrDst = zeros(k,1);
parfor nn=1:k
    tmp         =lcc(x, t(randperm(n)), max_slope, con);
    corrDst(nn) =tmp.corr;
end
clear tmp

if isnan(DATA.corr) %For some reason (e.g. all pos the same) corr is nan
    DATA.psim=nan; % so set p val to be nan
else
    if logical(sign(DATA.corr)+1) %if corr is +ve - test for prop of geting higher
        corrDst=sort(corrDst); %assending order
        sigInd=find(corrDst>=DATA.corr,1);
        DATA.psim = (k-(sigInd-1))/k; %p value
        
    else %Corr is negative
        corrDst=sort(corrDst,1,'descend');
        sigInd=find(corrDst<=DATA.corr,1);
        DATA.psim = (k-(sigInd-1))/k; %p value
    end
    
    if isempty(sigInd) %Catch situation where no value in dist exceeds test variable
        DATA.psim=0;
    end
end

end



% --- SUBFUNCTIONS --------------------------------------------------------
function DATA   = lcc(x,t,max_slope,con)
% lcc Linear Circular correlation does most of the work, is in a
% subfunction because I need to loop over it to get a p value


% 1) Performs slope optimisation using fminbnd and find intercept
[DATA.slope_opt,DATA.fval_opt]=fminbnd(@(m) cost(m,x,t),...
    con(1)*max_slope, con(2)*max_slope, optimset('TolFun',1e-3, 'TolX', 1e-2)); %-0.000001
DATA.phase_opt = atan2(sum(sin(t - DATA.slope_opt*x)),...
    sum(cos(t - DATA.slope_opt*x)));


% 2)CB added Now get circ-linear corr coef by converting to circ variables (eq 3&4
%of Kempter). NB phi is equivalent of t here (i.e. phase angle) and x is x
%(i.e. position). And theta is the linear variable x converted into a
%circular variable - again see Kempter but note that conversion is always
%with a +ve gradient so corr will always be +ve
theta=mod(abs(DATA.slope_opt)*x, 2*pi); %Now circular between 0 and 2pi


%3) Now have two circular variables - take circ_circ_corr between them. Have
%tried several methods.

%In principal the method in the Kempter (2012) paper should be the
%similar to the method from Fisher but when I used Kempter found that
%sign of corr didn't always agree with sign of gradient. Other authors
%(e.g.) Hasselmo also find this and manually correct correlation value.
% Alternative is code from AJ that implement circ_circ correlation
%from p151 of Fisher. using the computation form in eq 6.35

% Comment one of the two methods
%Fisher method
% DATA.corr   =ccc(theta,t);

%Kempter method
DATA.corr   =kempCorr(theta, t);
% Check that sign of corr matchs that of slope if not correct
if sign(DATA.corr) ~= sign(DATA.slope_opt)
    DATA.corr=-DATA.corr;
end


end


function [cost] = cost(m,x,t)
%% cost function to be minimised
%parameters: m=line slope, b=line intercept, x=data vector, k=von M
%concentration. Currently ommited.
alpha = t - m*x;
cost = -circ_r(alpha);
end


function [corr]=kempCorr(theta, t)
%Correlation described in Kempter et al (2012) see eq3/. See notes above
%about this not working - might be atypo I've not picked up. Left for
%completness.
% t phase values
% theta - circularised linear position variable


%First calculate tBar and thetaBar which are just circular mean - use own
%function for this cb_circMean [which is in CB_Universal folder]. Values
%cb_circMean works in rads
tBar        =cb_circMean(t);
thetaBar    =cb_circMean(theta);

corr= sum(sin(t-tBar).* sin(theta-thetaBar)) / ...
    sqrt( sum( sin(t-tBar).^2) * sum( sin(theta-thetaBar).^2)); %eq3
end


function [rho] = ccc(theta,phi)
% Subfunction to calculate correlation between two random circular variables
%   Method followed is the same as in $6.3.3 Fisher (1993), Statistical
%   Analysis of Circular Data, Cambridge University Press, ISBN: 0 521 56890 0
% Coded by AJ coppied form circ_circ_corr function
n = size(theta,1);
A = sum(cos(theta).*cos(phi));
B = sum(sin(theta).*sin(phi));
C = sum(cos(theta).*sin(phi));
D = sum(sin(theta).*cos(phi));
E = sum(cos(2*theta));
F = sum(sin(2*theta));
G = sum(cos(2*phi));
H = sum(sin(2*phi));

rho = 4*(A.*B - C.*D)./sqrt((n^2 - E.^2 - F.^2).*(n^2 - G.^2 - H.^2));
end